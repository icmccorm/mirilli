[["introduction.html", "Audit 1 Introduction", " Audit Ian McCormack 2023-06-20 1 Introduction "],["quantitative-results.html", "2 Quantitative Results 2.1 ABI Distribution 2.2 Improper Type Errors", " 2 Quantitative Results We began with a snapshot of the crates.io database taken on 12/20/2022, which contained 113,632 crates. After filtering out crates without any valid published versions, 109,348 crates remained. We ran our linting tool on this population. Prior to linting, we found that the latest version of 0 crates contained an empty archive when downloaded from crates.io. For crates with non-empty archives, 87,725 passed the early linting stage, while 21,623 failed it. Of those that passed the early linting stage, 85,452 passed the late linting stage, while 2,273 failed it. We use the subset of crates that passed both linting stages as the basis for our study, which comprises 75% of all crates in the database. Though -6,471 crates that passed the late linting stage failed to compile, we still include these in our sample to avoid excluding crates that have valid Rust code but are missing dependencies that cargo cannot provide. 2.1 ABI Distribution Both the early and late lints recorded the number of occurrences of each ABI for the rust functions, foreign functions, and static items declared in each crate. We merged results from the early and late lints by recording the location in source code where each foreign item occurre and eliminating duplicate results. This ensures a more accurate count of foreign ABI use than using only the late lint, as has been common in prior work, given that some crates may pass the early lint but then fail the late lint due to missing dependencies that cargo cannot provide. ## Warning in full_join(., early_abis, by = c(&quot;crate_name&quot;, &quot;category&quot;, &quot;abi&quot;, : Detected an unexpected many-to-many relationship between `x` and `y`. ## ℹ Row 1522 of `x` matches multiple rows in `y`. ## ℹ Row 1904 of `y` matches multiple rows in `x`. ## ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. ## # A tibble: 21 × 3 ## # Groups: abi [12] ## abi category `n()` ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C foreign_functions 8246366 ## 2 C rust_functions 108809 ## 3 C static_items 11917 ## 4 C-unwind foreign_functions 1 ## 5 C-unwind rust_functions 18 ## 6 cdecl foreign_functions 2 ## 7 efiapi rust_functions 5 ## 8 msp430-interrupt foreign_functions 2 ## 9 msp430-interrupt rust_functions 1 ## 10 stdcall foreign_functions 154 ## # ℹ 11 more rows 2.2 Improper Type Errors We observed 16,407 type errors in foreign bindings, which occurred for 227 unique crates. Of these crates, there were 166 that globally disabled the improper_ctypes lint, 90 that globally disabled the improper_types_definitions lint, and 86 that globally disabled both lints. Alternatively, there were 41 crates that selectively disabled the improper_ctypes lint, 11 that selectively disabled the improper_types_definitions lint, and 1 crates that selectively disabled both lints. Combined, this results in 207 crates that disabled improper_ctypes, 101 that disabled improper_types_definitions, and 87 that disabled both lints in some fashion. We classify errors as unique based on three factors. The first is the error type, of which there are 22 that the improper_ctypes lints will produce. The same error type can occur for multiple data types, of which there are 27. However, not every error type can occur for every data type; some, such as the “Str” error type, will only occur for the “Str” data type. We also classify two otherwise identical errors as being unique if they are associated with different categories of foreign items. There are three foreign item categories: rust functions, foreign functions, and foreign static items. The table below summarizes the quantity and types of errors observed. Error counts to the right of a ‘/’ were hidden from the user. ## # A tibble: 4 × 4 ## Category `# Crates` `# Unique Errors` Total ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Foreign Functions 145 / 92 14 / 13 15756 / 14106 ## 2 Rust Functions 79 / 19 12 / 7 467 / 242 ## 3 Static Items 11 / 5 7 / 3 184 / 169 ## 4 All 227 / 109 33 / 23 16407 / 14517 The following table displays hidden error counts by error type and data type. ## # A tibble: 14 × 6 ## Type Error `Foreign Functions` `Foreign Items` `Rust Functions` Total ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adt EnumNoRep… 27 7 23 57 ## 2 Adt StructFie… 8001 161 7 8169 ## 3 Adt StructNon… 2 0 0 2 ## 4 Adt UnionLayo… 1196 0 55 1251 ## 5 Adt OnlyPhant… 1 0 0 1 ## 6 Array -- 5 0 0 5 ## 7 Char -- 2 0 0 2 ## 8 Dynamic Dyn 3 0 10 13 ## 9 FnPtr -- 286 1 0 287 ## 10 Int Num128Bit 1 0 66 67 ## 11 Slice -- 1 0 0 1 ## 12 Tuple -- 7 0 23 30 ## 13 Uint Num128Bit 4574 0 58 4632 ## 14 All All 14106 169 242 14517 "],["sampling-for-qualitative-analysis.html", "3 Sampling for Qualitative Analysis", " 3 Sampling for Qualitative Analysis We target the 14,517 error occurrences that were hidden for our qualitative content analysis. We treat errors occurring for foreign functions and foreign static types as belonging to the group ‘Declarations’, which contributed to 14,275 errors, or 98% of all error occurrences. Within this group, improper 128-bit types and fieldless struct types corresponded to 89% of hidden errors, respectively. There were only 242 errors associated with Rust functions. We sample all errors associated with Rust functions for qualitative analysis. However, we use random sampling for errors associated with foreign declarations. This random sampling occurs in across two subpopulations. The first population of errors contains the 98% attributed to 128-bit types and fieldless structs, while the second contains all other errors. "],["references.html", "References", " References "]]

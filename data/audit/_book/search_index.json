[["introduction.html", "Audit 1 Introduction", " Audit Ian McCormack 2023-05-26 1 Introduction "],["quantitative-results.html", "2 Quantitative Results 2.1 ABI Distribution 2.2 Improper Type Errors", " 2 Quantitative Results We began with a snapshot of the crates.io database taken on 12/20/2022, which contained 113,632 crates. After filtering out crates without any valid published versions, 109,348 crates remained. We ran our linting tool on this population. Prior to linting, we found that the latest version of 13 crates contained an empty archive when downloaded from crates.io. For crates with non-empty archives, 38,707 passed the early linting stage, while 70,641 failed it. Of those that passed the early linting stage, 37,804 passed the late linting stage, while 903 failed it. We use the subset of crates that passed both linting stages as the basis for our study, which comprises 33% of all crates in the database. Though 1,156 crates that passed the late linting stage failed to compile, we still include these in our sample to avoid excluding crates that have valid Rust code but are missing dependencies that cargo cannot provide. 2.1 ABI Distribution Both the early and late lints recorded the number of occurrences of each ABI for the rust functions, foreign functions, and static items declared in each crate. We merged results from the early and late lints by recording the location in source code where each foreign item occurre and eliminating duplicate results. This ensures a more accurate count of foreign ABI use than using only the late lint, as has been common in prior work, given that some crates may pass the early lint but then fail the late lint due to missing dependencies that cargo cannot provide. ## Warning in full_join(., early_abis, by = c(&quot;crate_name&quot;, &quot;category&quot;, &quot;abi&quot;, : Detected an unexpected many-to-many relationship between `x` and `y`. ## ℹ Row 1 of `x` matches multiple rows in `y`. ## ℹ Row 1073 of `y` matches multiple rows in `x`. ## ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. ## # A tibble: 13 × 3 ## # Groups: abi [8] ## abi category `n()` ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C foreign_functions 1642548 ## 2 C rust_functions 14708 ## 3 C static_items 3171 ## 4 C-unwind rust_functions 3 ## 5 efiapi rust_functions 1 ## 6 system foreign_functions 532 ## 7 system rust_functions 756 ## 8 sysv64 foreign_functions 2 ## 9 sysv64 rust_functions 16 ## 10 thiscall foreign_functions 2814 ## 11 unadjusted foreign_functions 12 ## 12 win64 foreign_functions 2 ## 13 win64 rust_functions 3 2.2 Improper Type Errors We observed 9,983 type errors in foreign bindings, which occurred for 79 unique crates. Of these crates, there were 16 that globally disabled the improper_ctypes lint, 6 that globally disabled the improper_types_definitions lint, and 6 that globally disabled both lints. Alternatively, there were 10 crates that selectively disabled the improper_ctypes lint, 2 that selectively disabled the improper_types_definitions lint, and 1 crates that selectively disabled both lints. Combined, this results in 26 crates that disabled improper_ctypes, 8 that disabled improper_types_definitions, and 7 that disabled both lints in some fashion. We classify errors as unique based on three factors. The first is the error type, of which there are 22 that the improper_ctypes lints will produce. The same error type can occur for multiple data types, of which there are 27. However, not every error type can occur for every data type; some, such as the “Str” error type, will only occur for the “Str” data type. We also classify two otherwise identical errors as being unique if they are associated with different categories of foreign items. There are three foreign item categories: rust functions, foreign functions, and foreign static items. The table below summarizes the quantity and types of errors observed. Error counts to the right of a ‘/’ were hidden from the user. ## # A tibble: 4 × 4 ## Category `# Crates` `# Unique Errors` Total ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Foreign Functions 52 / 22 12 / 9 9594 / 8741 ## 2 Rust Functions 26 / 6 11 / 6 286 / 172 ## 3 Static Items 3 / 1 3 / 1 103 / 99 ## 4 All 79 / 27 26 / 16 9983 / 9012 The following table displays hidden error counts by error type and data type. ## # A tibble: 10 × 6 ## Type Error `Foreign Functions` `Foreign Items` `Rust Functions` Total ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adt EnumNoRep… 21 0 1 22 ## 2 Adt StructFie… 5809 99 7 5915 ## 3 Adt UnionLayo… 404 0 17 421 ## 4 Array -- 1 0 0 1 ## 5 Char -- 1 0 0 1 ## 6 Dynamic Dyn 2 0 0 2 ## 7 Int Num128Bit 1 0 66 67 ## 8 Tuple -- 7 0 23 30 ## 9 Uint Num128Bit 2495 0 58 2553 ## 10 All All 8741 99 172 9012 "],["sampling-for-qualitative-analysis.html", "3 Sampling for Qualitative Analysis", " 3 Sampling for Qualitative Analysis We target the 9,012 error occurrences that were hidden for our qualitative content analysis. We treat errors occurring for foreign functions and foreign static types as belonging to the group ‘Declarations’, which contributed to 8,840 errors, or 98% of all error occurrences. Within this group, improper 128-bit types and fieldless struct types corresponded to 95% of hidden errors, respectively. There were only 172 errors associated with Rust functions. We sample all errors associated with Rust functions for qualitative analysis. However, we use random sampling for errors associated with foreign declarations. This random sampling occurs in across two subpopulations. The first population of errors contains the 98% attributed to 128-bit types and fieldless structs, while the second contains all other errors. "],["references.html", "References", " References "]]

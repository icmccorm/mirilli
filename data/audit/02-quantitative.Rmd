# Quantitative Results
```{r echo=FALSE}
unfiltered_total <- unfiltered %>% nrow
total <- all %>% nrow
passed_early <- finished_early %>% nrow
early_j <- finished_early
early_j$early <- TRUE
failed <- all %>% left_join(early_j, by=c("crate_name"))

failed_early <- total - passed_early
passed_late <- finished_late %>% nrow
failed_late <- passed_early - passed_late
nfailed_download <- failed_download %>% nrow
compiled <- total - (failed_compilation %>% nrow)
failed_compilation <- passed_late - compiled
had_valid <- finished_late 

percent_sampled <- passed_late / unfiltered_total * 100

fc <-function(n) {
  format(round(as.numeric(n), 0), nsmall=0, big.mark=",")
} 
```

We began with a snapshot of the [crates.io](https://crates.io/data-access) database taken on 12/20/2022, which contained `r fc(unfiltered_total)` crates. After filtering out crates without any valid published versions, `r fc(total)` crates remained. We ran our linting tool on this population. Prior to linting, we found that the latest version of `r fc(nfailed_download)` crates contained an empty archive when downloaded from crates.io. For crates with non-empty archives, `r fc(passed_early)` passed the early linting stage, while `r fc(failed_early)` failed it. Of those that passed the early linting stage, `r fc(passed_late)` passed the late linting stage, while `r fc(failed_late)` failed it. We use the subset of crates that passed both linting stages as the basis for our study, which comprises **`r fc(percent_sampled)`% of all crates** in the database. Though `r fc(failed_compilation)` crates that passed the late linting stage failed to compile, we still include these in our sample to avoid excluding crates that have valid Rust code but are missing dependencies that cargo cannot provide.

## ABI Distribution
Both the early and late lints recorded the number of occurrences of each ABI for the rust functions, foreign functions, and static items declared in each crate. We merged results from the early and late lints by recording the location in source code where each foreign item occurre and eliminating duplicate results. This ensures a more accurate count of foreign ABI use than using only the late lint, as has been common in prior work, given that some crates may pass the early lint but then fail the late lint due to missing dependencies that cargo cannot provide. 
```{r echo=FALSE}
early_abis$status = "early"
late_abis$status = "late"
all_abis <- late_abis %>% full_join(early_abis, by=c("crate_name", "category", "abi", "file", "start_line", "start_col", "end_line", "end_col")) %>% group_by(abi, category) %>% summarize(n())
all_abis
```



## Improper Type Errors

```{r include = FALSE}
discriminant_counts %>%
  group_by(crate_name, category) %>%
  summarize(num_errs = sum(count)) %>% 
  group_by(category) %>% 
  summarize(
    num_crates = n(), 
    mean_errs = mean(num_errs), 
    max_errs = max(num_errs), 
    min_errs = min(num_errs), 
    stdev_errs = sd(num_errs)
  )

unique_errors <- einfo %>% 
  select(discriminant, err_text) %>% 
  unique %>% 
  nrow

unique_crates <- einfo %>% select(crate_name) %>% unique %>% nrow

fc <-function(n) {
  format(round(as.numeric(n), 0), nsmall=0, big.mark=",")
} 
```

```{r echo = FALSE}

globally <- lint_info %>% filter(decl_disabled + defn_disabled > 0)
decl_disabled <-globally %>% filter(decl_disabled) %>% select(crate_name) %>% unique
defn_disabled <- globally %>% filter(defn_disabled) %>% select(crate_name) %>% unique
both_disabled <- globally %>% filter(defn_disabled) %>% filter(decl_disabled) %>% select(crate_name) %>% unique

g_decl_disabled <- decl_disabled %>% nrow # 40
g_defn_disabled <- defn_disabled %>% nrow # 11
g_both_disabled <- both_disabled %>% nrow # 10

partially <- discriminant_counts %>% select(crate_name, category, ignored) %>% filter(ignored == TRUE)
partially <- partially %>% mutate(category = ifelse(as.character(category) %in% c('static_items','foreign_functions'), "decl", as.character(category)))
partially <- partially %>% mutate(category = ifelse(as.character(category) %in% c('rust_functions'), "defn", as.character(category)))

partial_defn <- partially %>% filter(category == 'defn') %>% select(crate_name) %>% unique # 12 
partial_decl <- partially %>% filter(category == 'decl') %>% select(crate_name) %>% unique #76
partial_both <- partially %>% select(crate_name, category) %>% group_by(crate_name) %>% unique %>%
summarize(n = n()) %>% filter(n == 2) %>% select(crate_name)

p_decl_disabled <- setdiff(partial_decl, decl_disabled) %>% nrow 
p_defn_disabled <- setdiff(partial_defn, defn_disabled) %>% nrow 
p_both_disabled <- setdiff(partial_both, both_disabled) %>% nrow 

b_decl_disabled <- union(partial_decl, decl_disabled) %>% nrow # 80
b_defn_disabled <- union(partial_defn, defn_disabled) %>% nrow # 19
b_both_disabled <- union(partial_both, both_disabled) %>% nrow # 88

disabled_somehow <- bind_rows((partially %>% select(crate_name)), (globally %>% select(crate_name))) %>% unique %>% nrow

```
We observed `r fc(sum(discriminant_counts$count))` type errors in foreign bindings, which occurred for `r unique_crates` unique crates. Of these crates, there were `r g_decl_disabled` that globally disabled the `improper_ctypes` lint, `r g_defn_disabled` that globally disabled the `improper_types_definitions` lint, and `r g_both_disabled` that globally disabled both lints. Alternatively, there were `r p_decl_disabled` crates that selectively disabled the `improper_ctypes` lint, `r p_defn_disabled` that selectively disabled the `improper_types_definitions` lint, and `r p_both_disabled` crates that selectively disabled both lints. Combined, this results in `r b_decl_disabled` crates that disabled `improper_ctypes`, `r b_defn_disabled` that disabled `improper_types_definitions`, and `r b_both_disabled` that disabled both lints in some fashion. 

We classify errors as unique based on three factors. The first is the error type, of which there are `r reasons %>% nrow` that the `improper_ctypes` lints will produce. The same error type can occur for multiple data types, of which there are `r discriminant_names %>% nrow`. However, not every error type can occur for every data type; some, such as the "Str" error type, will only occur for the "Str" data type. We also classify two otherwise identical errors as being unique if they are associated with different categories of foreign items. There are three foreign item categories: rust functions, foreign functions, and foreign static items. 

The table below summarizes the quantity and types of errors observed. Error counts to the right of a '/' were hidden from the user.

```{r echo = FALSE}

unique_errors_only <- function (df) {
  df %>% distinct(category, discriminant, reason)
}

process_counts <- function(df) {
  df %>% group_by(crate_name, category) %>%
    summarize(num_errors = sum(count)) %>%
    group_by(category)
}

count_summary_all <- discriminant_counts %>%
  process_counts %>%
  summarize(
    n_crates_all = n(),
    errs_all = sum(num_errors),
    mean_errs_all = round(mean(num_errors), 1),
    stdev_errs_all = round(sd(num_errors), 1),
    max_errs_all = max(num_errors)
  )

unique_all <- discriminant_counts %>% select(crate_name, category, discriminant, reason, abi, err_text, ignored) %>% unique_errors_only %>%
  group_by(category) %>% summarize(n_unique_all=n())
unique_ignored <- discriminant_counts %>% select(crate_name, category, discriminant, reason, abi, ignored) %>% filter(ignored == TRUE) %>% unique_errors_only %>%
  group_by(category) %>% summarize(n_unique_ign=n())

count_summary_ign <-discriminant_counts %>% 
  filter(ignored == TRUE) %>%
  process_counts %>%
  summarize(
    n_crates_ign = n(),
    errs_ign = sum(num_errors),
    mean_errs_ign = round(mean(num_errors), 1),
    stdev_errs_ign = round(sd(num_errors), 1),
    max_errs_ign = max(num_errors)
  )

count_summary <- count_summary_all %>% inner_join(count_summary_ign, by=("category"))
count_summary$n_crates <- paste(count_summary_all$n_crates_all, "/", count_summary_ign$n_crates_ign)
count_summary$n_errs <- paste(count_summary_all$errs_all, "/", count_summary_ign$errs_ign)
count_summary$mean_errs <- paste(count_summary_all$mean_errs_all, "/", count_summary_ign$mean_errs_ign)
count_summary$stdev_errs <- paste(count_summary_all$stdev_errs_all, "/", count_summary_ign$stdev_errs_ign)
count_summary$max_errs <- paste(count_summary_all$max_errs_all, "/", count_summary_ign$max_errs_ign)

count_summary <- count_summary %>% inner_join(unique_all, by=("category"))
count_summary <- count_summary %>% inner_join(unique_ignored, by=("category"))
count_summary$n_unique <- paste(count_summary$n_unique_all, "/", count_summary$n_unique_ign)

count_summary <- count_summary %>% select(category, n_crates, n_unique, n_errs, mean_errs, stdev_errs, max_errs)
count_summary <- count_summary %>% mutate(category = ifelse(as.character(category) == "rust_functions", "Rust Functions", as.character(category)))
count_summary <- count_summary %>% mutate(category = ifelse(as.character(category) == "foreign_functions", "Foreign Functions", as.character(category)))
count_summary <- count_summary %>% mutate(category = ifelse(as.character(category) == "static_items", "Static Items", as.character(category)))

all_counts <- discriminant_counts %>% group_by(crate_name) %>%
    summarize(num_errors = sum(count))

all_counts_ign <- discriminant_counts %>% group_by(crate_name) %>%
  filter(ignored == TRUE) %>%
  summarize(num_errors = sum(count))

unique_ungrouped <- discriminant_counts %>% select(crate_name, category, discriminant, reason, abi, err_text, ignored) %>%
  unique_errors_only %>% nrow

unique_ungrouped_ign <- discriminant_counts %>% select(crate_name, category, discriminant, reason, abi, err_text, ignored) %>%
  filter(ignored == TRUE) %>%
  unique_errors_only %>% nrow

count_summary[nrow(count_summary) + 1,] <- list(
  'All', # Category
  paste(all_counts %>% nrow, '/', all_counts_ign %>% nrow), # Crates
  paste(unique_ungrouped, '/', unique_ungrouped_ign), # Crates
  paste(sum(all_counts$num_errors), '/', sum(all_counts_ign$num_errors)), # Unique Errors
  paste(round(mean(all_counts$num_errors), 1), '/', round(mean(all_counts_ign$num_errors), 1)), # Mean
  paste(round(sd(all_counts$num_errors), 1), '/', round(sd(all_counts_ign$num_errors), 1)), # St.Dev
  paste(max(all_counts$num_errors), '/', max(all_counts_ign$num_errors)) # Max
)
colnames(count_summary) <- c("Category", "# Crates", "# Unique Errors", "Total", "Mean", "St.Dev", "Max")

count_summary %>% select("Category", "# Crates", "# Unique Errors", "Total")
```


The following table displays hidden error counts by error type and data type. 

```{r echo = FALSE}
named_counts <- discriminant_counts %>% 
  inner_join(discriminant_names, by=c("discriminant")) %>% filter(ignored == TRUE)

decls <- named_counts %>% filter(category %in% c("foreign_functions"))
defns <- named_counts %>% filter(category %in% c("rust_functions"))
decls_items <- named_counts %>% filter(category %in% c("static_items"))

discrim_counts <- discriminant_counts %>% 
  select(crate_name, category, discriminant, reason, abi, err_text, ignored) %>% 
  unique_errors_only %>% 
  group_by(reason, discriminant) %>% 
  summarize(n_unique=n())

decls_items_counts <- decls_items %>%
  group_by(reason, discriminant) %>% 
  summarize(fi_count = sum(count)) %>%
  inner_join(reasons, by=c("reason")) %>%
  inner_join(discriminant_names, by=c("discriminant")) 

decls_counts <- decls %>% 
  group_by(reason, discriminant) %>%
  summarize(ff_count = sum(count)) %>%
  inner_join(reasons, by=c("reason")) %>%
  inner_join(discriminant_names, by=c("discriminant")) 

defns_counts <- defns %>% 
  group_by(reason, discriminant) %>%
  summarize(ef_count = sum(count)) %>%
  inner_join(reasons, by=c("reason")) %>%
  inner_join(discriminant_names, by=c("discriminant")) 

final <- decls_counts %>%
  full_join(decls_items_counts, by=c("discriminant","reason", "reason_name", "type_name")) %>% 
  full_join(defns_counts, by=c("discriminant","reason", "reason_name", "type_name")) %>%
  full_join(discrim_counts, by=c("discriminant","reason")) %>%
  mutate(across(where(is.numeric), ~ replace_na(.x, 0))) %>%
  ungroup() %>%
  select(type_name, reason_name, ff_count, fi_count, ef_count)

final$total_occurrences <- final$ff_count + final$fi_count + final$ef_count
hidden_errors <- final %>% filter(total_occurrences > 0) %>% arrange(type_name)

filtered_presentation <- hidden_errors %>% mutate(reason_name = ifelse(as.character(type_name) == as.character(reason_name), "--", as.character(reason_name)))
filtered_presentation[nrow(filtered_presentation) + 1,] <- list(
  'All', 
  'All',
  sum(hidden_errors$ff_count),
  sum(hidden_errors$fi_count),
  sum(hidden_errors$ef_count),
  sum(hidden_errors$total_occurrences)
)
colnames(filtered_presentation) <- c("Type", "Error", "Foreign Functions", "Foreign Items", "Rust Functions", "Total")
filtered_presentation

```

```{r echo=FALSE}
num_hidden_errors_decls <- sum(decls_counts$ff_count) + sum(decls_items_counts$fi_count)
num_hidden_errors_defns <- sum(defns_counts$ef_count)
num_hidden_errors <- num_hidden_errors_decls + num_hidden_errors_defns
improper_128_bit_foreign <- sum((decls_counts %>% filter(reason_name == "Num128Bit"))$ff_count) + sum((decls_items_counts %>% filter(reason_name == "Num128Bit"))$fi_count)

struct_fieldless_foreign <- (decls_counts %>% filter(reason_name == "StructFieldless"))$ff_count + (decls_items_counts %>% filter(reason_name == "StructFieldless"))$fi_count
```
# Sampling for Qualitative Analysis
We target the `r fc(num_hidden_errors)` error occurrences that were hidden for our qualitative content analysis. We treat errors occurring for foreign functions and foreign static types as belonging to the group 'Declarations', which contributed to `r fc(num_hidden_errors_decls)` errors, or `r fc(num_hidden_errors_decls / num_hidden_errors * 100)`% of all error occurrences. Within this group, improper 128-bit types and fieldless struct types corresponded to `r fc((struct_fieldless_foreign + improper_128_bit_foreign) / num_hidden_errors_decls * 100)`% of hidden errors, respectively. There were only `r fc(num_hidden_errors_defns)` errors associated with Rust functions. 


We sample all errors associated with Rust functions for qualitative analysis. However, we use random sampling for errors associated with foreign declarations. This random sampling occurs in across two subpopulations. The first population of errors contains the `r fc(num_hidden_errors_decls / num_hidden_errors * 100)`% attributed to 128-bit types and fieldless structs, while the second contains all other errors. 




```{r echo=FALSE}

# large <- function(x){
#   paste0('\textbf{', x, '}')
# }
# addtorow <- list()
# addtorow$pos <- list(0, 0)
# addtorow$command <- c("& & & \\multicolumn{4}{c}{\\# Occurrences} \\\\\n",
# "Category & \\# Crates & \\# Unique & Total & Mean & St.Dev. & Max \\\\\n")
# xt_counts = xtable(
#   count_summary, 
#   type = "latex", 
#   digits=c(0,0,0,0,0,1,1,0),
 
# )

# align(xt_counts) <- "llcc|cccc"
# print(xt_counts, 
#       include.rownames = FALSE,
#       add.to.row = addtorow, 
#       file = "../latex/err_counts.tex",
#       include.colnames = FALSE,
#       sanitize.colnames.function = large,
#       floating=FALSE,
#       latex.environments=NULL
# )

# addtorow <- list()
# addtorow$pos <- list(0, 0)
# addtorow$command <- c("& & & \\multicolumn{4}{c}{\\# Hidden Occurrences} \\\\\n",
# "Error Category & Error & \\# Unique & Foreign Functions & Foreign Items & Rust Functions & Total \\\\\n")
# xt_type_counts <- xtable(
#   filtered, 
#   type = "latex", 
#   digits=c(0,0,0,0,0,0,0,0),
#   floating=FALSE,
#   latex.environments=NULL
# )
# align(xt_type_counts) <- "lllc|cccc"
# print(xt_type_counts, 
#       include.rownames = FALSE,
#       add.to.row = addtorow, 
#       file = "../latex/err_type_counts.tex",
#       include.colnames = FALSE,
#       sanitize.colnames.function = large,
#       floating=FALSE,
#       latex.environments=NULL
#     )
```